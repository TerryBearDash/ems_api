"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const package_manager_1 = require("../../lib/package-manager");
class PackageManagerController {
    constructor(app, websocket) {
        this.app = app;
        this.websocket = websocket;
        this.packageManager = new package_manager_1.PackageManager(this.app.path);
    }
    install(req, res) {
        this.app.watcher.disable();
        const name = this.getPkgFromRequest(req);
        this.packageManager.install(name, (data, error) => {
            this.app.logger.log(data);
        }).then(data => {
            this.app.watcher.enable();
            return res.status(200).send({ data });
        }).catch(err => {
            this.app.watcher.enable();
            return res.status(501).send(err);
        });
    }
    installAll(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._kill(this.proc);
            try {
                const result = yield this.packageManager.installAllInBackground();
                this.proc = result.proc;
                res.status(200).send();
            }
            catch (err) {
                return res.status(500).send(err);
            }
            this.websocket.broadcast({
                type: 'root:install-all:progress',
                data: this.app.path
            });
            this.websocket.broadcast({
                type: 'root:install-all:progress',
                data: `${this.packageManager.managerName === 'yarn' ? '$ yarn install' : '$ npm install'}`
            });
            this.proc.stdout.on('data', d => {
                this.websocket.broadcast({
                    type: 'root:install-all:progress',
                    data: d.toString()
                });
            });
            this.proc.stderr.on('data', d => {
                this.websocket.broadcast({
                    type: 'root:install-all:progress',
                    data: d.toString()
                });
            });
            this.proc.on('close', (code, signal) => {
                if (code) {
                    this.websocket.broadcast({
                        type: 'root:install-all:fail',
                        data: code + signal
                    });
                }
                else {
                    this.websocket.broadcast({
                        type: 'root:install-all:success'
                    });
                }
            });
        });
    }
    uninstall(req, res) {
        this.app.watcher.disable();
        const name = this.getPkgFromRequest(req);
        try {
            this.packageManager.uninstall(name, (data, error) => {
                this.app.logger.log(data);
            }).then(data => {
                this.app.watcher.enable();
                return res.status(200).send({ data });
            }).catch(err => {
                this.app.watcher.enable();
                return res.status(501).send(err);
            });
        }
        catch (e) {
            this.app.watcher.enable();
            return res.status(502).send(e);
        }
    }
    upgrade(req, res) {
        this.app.watcher.disable();
        const name = this.getPkgFromRequest(req);
        try {
            this.packageManager.upgrade(name, (data, error) => {
                this.app.logger.log(data);
            }).then(data => {
                this.app.watcher.enable();
                return res.status(200).send({ data });
            }).catch(e => {
                this.app.watcher.enable();
                return res.status(500).send(e);
            });
        }
        catch (e) {
            this.app.watcher.enable();
            return res.status(502).send(e);
        }
    }
    getPkgFromRequest(req) {
        let pkg = req.params.dependency;
        if (req.params[0]) {
            pkg += req.params[0];
        }
        return pkg;
    }
    _kill(stream) {
        if (!stream) {
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
            const isWin = /^win/.test(process.platform);
            if (!isWin) {
                stream.kill('SIGINT');
                return resolve();
            }
            else {
                const cp = require('child_process');
                cp.exec('taskkill /PID ' + stream.pid + ' /T /F', (error, stdout, stderr) => { return resolve(); });
            }
        });
    }
}
exports.PackageManagerController = PackageManagerController;
//# sourceMappingURL=package-manager.ctrl.js.map