"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const oauth2orize = require("oauth2orize");
const crypto = require("crypto");
const passport = require("passport");
// BasicStrategy = require('passport-http').BasicStrategy
const passport_oauth2_client_password_1 = require("passport-oauth2-client-password");
const passport_http_bearer_1 = require("passport-http-bearer");
class OAuth {
    constructor(app) {
        this.app = app;
        this.tokens = [];
        // Create the server
        this.server = oauth2orize.createServer();
    }
    get token() {
        if (!this.app.rootPassword) {
            return (req, res, next) => res.status(200).send({
                access_token: null
            });
        }
        return [
            passport.authenticate(['clientPassword'], { session: false }),
            this.server.token(),
            this.server.errorHandler()
        ];
    }
    get isAuth() {
        if (!this.app.rootPassword) {
            return (req, res, next) => next();
        }
        return passport.authenticate('accessToken', { session: false });
    }
    initialize() {
        this.app.server.expressApp.use(passport.initialize());
        this.app.server.expressApp.use(passport.session());
        this.server.exchange(oauth2orize.exchange.clientCredentials((client, scope, done) => this.generateToken().then(token => {
            // TODO: currently only memory based => need to create system entity for access tokens
            const tokenHash = crypto.createHash('sha1').update(token).digest('hex');
            this.tokens.push({
                token: tokenHash,
                expires_in: new Date(new Date().getTime() + 3600 * 48 * 1000),
                username: 'admin',
                scope: ['*']
            });
            // Return the token
            return done(null /* No error*/, token /* The generated token*/, null /* The generated refresh token, none in this case */, null /* Additional properties to be merged with the token and send in the response */);
        })));
        passport.use('clientPassword', new passport_oauth2_client_password_1.Strategy(this.verifyLogin.bind(this)));
        passport.use('accessToken', new passport_http_bearer_1.Strategy(this.verifyToken.bind(this)));
    }
    static getTokenFromHeaders(req) {
        const h = req.headers['Authorization'];
        const prefix = 'Bearer ';
        if (!h.startWith(prefix)) {
            return null;
        }
        return h.substr(prefix.length);
    }
    verifyLogin(clientId, clientSecret, done) {
        if (clientId == 'admin' && clientSecret == this.app.rootPassword) {
            return done(null, { username: 'admin' });
        }
        else {
            return done(null, false);
        }
    }
    verifyToken(accessToken, done) {
        if (!accessToken) {
            return done(null, false);
        }
        const accessTokenHash = crypto.createHash('sha1').update(accessToken).digest('hex');
        const token = this.tokens.find(t => t.token == accessTokenHash);
        if (!token) {
            return done(null, false);
        }
        if (new Date() > token.expires_in) {
            this.clearExpiredTokens();
            done(null, false);
        }
        else {
            const info = { scope: '*' };
            done(null, { username: 'admin' }, info);
        }
    }
    clearExpiredTokens() {
        this.tokens = this.tokens.filter(token => {
            return token.expires_in.getTime() <= new Date().getTime();
        });
    }
    generateToken({ stringBase = 'base64', byteLength = 32 } = {}) {
        return new Promise((resolve, reject) => {
            crypto.randomBytes(byteLength, (err, buffer) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(buffer.toString(stringBase));
                }
            });
        });
    }
}
exports.OAuth = OAuth;
//# sourceMappingURL=oauth.js.map