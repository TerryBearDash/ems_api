"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const error_1 = require("../error");
class QueryParamResolver {
    static resolve(field, params) {
        if (typeof field.value == 'string' && field.value.substr(0, 1) == '=') {
            let paramName = field.name;
            if (field.value.length > 1) {
                paramName = field.value.substr(1);
            }
            if (params.params && params.params[paramName] !== undefined) {
                return params.params[paramName];
            }
            if (params.data && params.data[paramName] !== undefined) {
                return params.data[paramName];
            }
            if (params[paramName] !== undefined) {
                return params[paramName];
            }
            throw new error_1.MateriaError('Missing required parameter: ' + paramName);
        }
        if (typeof field.value == 'string' && field.value.substr(0, 1) == '%') {
            let paramName = field.name;
            if (field.value.length > 1) {
                paramName = field.value.substr(1);
            }
            if (params.headers) {
                return params.headers[paramName];
            }
            throw new error_1.MateriaError('header not found ' + paramName);
        }
        return field.value;
    }
}
exports.QueryParamResolver = QueryParamResolver;
class Query {
    constructor(entity, id) {
        this.entity = entity;
        this.entity = entity;
        // this.history = entity.app.history
        this.id = id;
        this.params = [];
    }
    handleBeforeActions(params, success) {
        return this.entity.app.actions.handle('beforeQuery', {
            entity: this.entity.name,
            query: this.id
        }, params, success);
    }
    handleAfterActions(params, response, success) {
        return this.entity.app.actions.handle('afterQuery', {
            entity: this.entity.name,
            query: this.id
        }, Object.assign({}, params, response), success);
    }
    updateOption(name, value, options) {
        return Promise.reject(new error_1.MateriaError('not implemented yet'));
    }
    hasParameters() {
        return this.params.length > 0;
    }
    getAllParams() {
        return this.params;
    }
    getParam(name) {
        for (const param of this.params) {
            if (param.name == name) {
                return param;
            }
        }
        return null;
    }
    hasRequiredParameters() {
        for (const param of this.params) {
            if (param.required) {
                return true;
            }
        }
        return false;
    }
    constructInclude(includeArray, includedName) {
        for (const entity of includedName) {
            const includeEntity = this.entity.app.entities.get(entity.entity);
            if (!includeEntity) {
                throw new error_1.MateriaError(`Cannot find included entity ${entity.entity}`);
            }
            const includePart = {
                model: includeEntity.model,
                attributes: entity.fields
            };
            if (entity.include) {
                includePart.include = [];
                const includeNames = entity.include;
                this.constructInclude(includePart.include, includeNames);
            }
            includeArray.push(includePart);
        }
    }
    paramsToJson() {
        if (!this.params) {
            return undefined;
        }
        const _params = [];
        for (const param of this.params) {
            const _param = {
                name: param.name,
                type: param.type
            };
            if (param.required) {
                _param['required'] = param.required;
            }
            if (param.component) {
                _param['component'] = param.component;
            }
            if (param.reference) {
                _param['reference'] = {
                    entity: param.reference.entity,
                    field: param.reference.field
                };
            }
            _params.push(_param);
        }
        return _params;
    }
}
exports.Query = Query;
//# sourceMappingURL=query.js.map