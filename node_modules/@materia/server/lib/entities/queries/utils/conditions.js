"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const condition_1 = require("./condition");
const query_1 = require("../../query");
const error_1 = require("../../../error");
const sequelize_1 = require("sequelize");
/*
Conditions manage a list of condition (associated with `operand`)
Conditions structure:
[
    {
        name: string,
        operator: string,
        value: string,
        operand: string (optional|default:AND)
        priorityLevel: integer (optional|default:0)
    },
    {
        ...
    }
]
*/
const SequelizeOperatorsKeys = {
    '=': sequelize_1.Op.eq,
    '!=': sequelize_1.Op.ne,
    '>': sequelize_1.Op.gt,
    '>=': sequelize_1.Op.gte,
    '<': sequelize_1.Op.lt,
    '<=': sequelize_1.Op.lte,
    'LIKE': sequelize_1.Op.like,
    'NOT LIKE': sequelize_1.Op.notLike,
    'ILIKE': sequelize_1.Op.iLike,
    'NOT ILIKE': sequelize_1.Op.notILike
};
class Conditions {
    constructor(conditions, query) {
        this.conditions = [];
        this.entity = query.entity;
        if (conditions) {
            for (const condition of conditions) {
                if (condition.entity && !this.entity.app.entities.get(condition.entity)) {
                    throw new error_1.MateriaError(`Could not find entity "${condition.entity}" in condition`);
                }
                this.conditions.push(new condition_1.Condition(condition, this.entity && this.entity.name));
            }
        }
    }
    toSequelize(params, entityName) {
        params = params || [];
        const $and = [], $or = [];
        for (const condition of this.conditions) {
            if (condition.name && condition.operator && condition.entity == entityName) {
                let cond;
                if (condition.operator == 'IS NULL') {
                    cond = { [sequelize_1.Op.eq]: null };
                }
                else if (condition.operator == 'IS NOT NULL') {
                    cond = { [sequelize_1.Op.ne]: null };
                }
                else {
                    let resolvedParam = query_1.QueryParamResolver.resolve(condition, params);
                    const opkey = SequelizeOperatorsKeys[condition.operator.toUpperCase()];
                    cond = {};
                    if ((condition.operator === 'LIKE'
                        || condition.operator === 'ILIKE'
                        || condition.operator === 'NOT LIKE'
                        || condition.operator === 'NOT ILIKE')
                        && resolvedParam.indexOf('%') === -1) {
                        resolvedParam = `%${resolvedParam}%`;
                    }
                    cond[opkey] = resolvedParam;
                }
                cond = { [condition.name]: cond };
                if (condition.operand && condition.operand.toUpperCase() == 'OR') {
                    $or.push(cond);
                }
                else {
                    $and.push(cond);
                }
            }
        }
        if ($or.length) {
            if ($and.length) {
                if ($and.length == 1) {
                    $or.push($and[0]);
                }
                else {
                    $or.push({ $and: $and });
                }
            }
            if ($or.length == 1) {
                return $or[0];
            }
            else {
                return { [sequelize_1.Op.or]: $or };
            }
        }
        else if ($and.length) {
            if ($and.length == 1) {
                return $and[0];
            }
            else {
                return { [sequelize_1.Op.and]: $and };
            }
        }
    }
    constructConditions(entities, params) {
        for (const entity of entities) {
            for (const condition of this.conditions) {
                if (condition && condition.entity == entity.model.name) {
                    entity.where = this.toSequelize(params, condition.entity);
                }
                if (entity.include) {
                    this.constructConditions(entity.include, params);
                }
            }
        }
    }
    discoverParams() {
        const params = [];
        this.conditions.forEach(condition => {
            if (condition.valueIsParam()) {
                let field;
                if (condition.entity != this.entity.name) {
                    field = this.entity.app.entities.get(condition.entity).getField(condition.name);
                }
                else {
                    field = this.entity.getField(condition.name);
                }
                if (!field) {
                    // impossible to find field ${condition.entity}.${condition.name} in query ${this.query.id}
                }
                let paramName = condition.name;
                if (condition.value.length > 1) {
                    paramName = condition.value.substr(1);
                }
                params.push({
                    name: paramName,
                    reference: {
                        entity: condition.entity,
                        field: condition.name
                    },
                    type: field.type,
                    component: field.component,
                    required: true
                });
            }
        });
        return params;
    }
    toJson() {
        const res = [];
        this.conditions.forEach((condition) => {
            res.push(condition.toJson());
        });
        return res;
    }
}
exports.Conditions = Conditions;
//# sourceMappingURL=conditions.js.map