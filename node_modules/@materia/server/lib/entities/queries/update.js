"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const query_1 = require("../query");
const conditions_1 = require("./utils/conditions");
class UpdateQuery extends query_1.Query {
    constructor(entity, id, opts) {
        super(entity, id);
        this.type = 'update';
        this.values = {};
        if (!opts) {
            opts = {};
        }
        if (opts.values) {
            this.values = opts.values;
        }
        this.conditions = new conditions_1.Conditions(opts.conditions, this);
        this.discoverParams();
    }
    refresh() { }
    discoverParams() {
        this.valuesType = {};
        this.params = [];
        Object.keys(this.values).forEach(fieldName => {
            if (this.values[fieldName] && this.values[fieldName].substr(0, 1) == '=') {
                this.valuesType[fieldName] = 'param';
                let paramName = fieldName;
                if (this.values[fieldName].length > 1) {
                    paramName = this.values[fieldName].substr(1);
                }
                const field = this.entity.getField(fieldName);
                this.params.push({
                    name: paramName,
                    type: field.type,
                    required: false,
                    component: field.component,
                    reference: {
                        entity: this.entity.name,
                        field: fieldName
                    }
                });
            }
            else {
                this.valuesType[fieldName] = 'value';
            }
        });
        this.params = this.params.concat(this.conditions.discoverParams());
    }
    resolveParams(params) {
        const res = {};
        for (const field in this.values) {
            if (field) {
                try {
                    res[field] = query_1.QueryParamResolver.resolve({ name: field, value: this.values[field] }, params);
                }
                catch (e) {
                    if (this.values[field].substr(0, 1) == '=') {
                        const t = this.getParam(this.values[field].substr(1));
                        if (t && t.required) {
                            throw e;
                        }
                    }
                }
            }
        }
        for (const field of this.params) {
            if (field && !this.values[field.name]) {
                try {
                    res[field.name] = query_1.QueryParamResolver.resolve({ name: field.name, value: '=' }, params);
                }
                catch (e) {
                    if (field.required) {
                        throw e;
                    }
                }
            }
        }
        return res;
    }
    run(params) {
        this.entity.app.logger.log(`${chalk_1.default.bold('(Query)')} Update - Run ${chalk_1.default.bold(this.entity.name)}.${chalk_1.default.bold(this.id)}`);
        this.entity.app.logger.log(` └── Parameters: ${JSON.stringify(params)}\n`);
        let updates, where;
        try {
            updates = this.resolveParams(params);
            where = this.conditions.toSequelize(params, this.entity.name);
        }
        catch (e) {
            return this.handleBeforeActions(params, false)
                .then(() => Promise.reject(e))
                .catch(() => Promise.reject(e));
        }
        return this.handleBeforeActions(params, true)
            .then(() => {
            const opts = { where: {} };
            if (where) {
                opts.where = where;
            }
            return this.entity.model.update(updates, opts);
        }).then(res => this.handleAfterActions(params, res, true)
            .then(() => res)
            .catch(e => res))
            .catch(e => this.handleAfterActions(params, null, false)
            .then(() => Promise.reject(e))
            .catch(() => Promise.reject(e)));
    }
    toJson() {
        const res = {
            id: this.id,
            type: 'update',
            opts: {
                values: this.values,
                conditions: this.conditions.toJson()
            }
        };
        return res;
    }
}
exports.UpdateQuery = UpdateQuery;
//# sourceMappingURL=update.js.map