"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const express = require("express");
const passport = require("passport");
const morgan = require("morgan");
const methodOverride = require("method-override");
const bodyParser = require("body-parser");
const errorHandler = require("errorhandler");
const compression = require("compression");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const http_1 = require("http");
const app_1 = require("./app");
const config_1 = require("./config");
const session_1 = require("./session");
const websocket_1 = require("./websocket");
/**
 * @class Server
 * @classdesc
 * Represent the server
 */
class Server {
    constructor(app) {
        this.app = app;
        this.started = false;
        this.disabled = false;
        this.passport = passport;
        this.sockets = new Map();
        this.stopped = false;
        this.session = new session_1.Session(app);
    }
    load() {
        this.expressApp = express();
        this.expressApp.use(bodyParser.json({ limit: '100mb', extended: true }));
        this.expressApp.use(bodyParser.urlencoded({ limit: '100mb', extended: false }));
        this.expressApp.use(methodOverride());
        this.expressApp.use(compression());
        if ((this.app.mode == app_1.AppMode.DEVELOPMENT || this.app.options.logRequests) && this.app.options.logRequests != false) {
            this.expressApp.use(morgan('dev'));
        }
        // TODO: Option to enable / disable CORS API call
        this.expressApp.use(function (req, res, next) {
            res.header('Access-Control-Allow-Origin', '*');
            res.header('Access-Control-Allow-Methods', 'GET,HEAD,OPTIONS,POST,PUT');
            res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
            next();
        });
        this.expressApp.use(errorHandler());
        this.server = http_1.createServer(this.expressApp);
        this.websocket = new websocket_1.WebsocketServers(this.app);
        this.sockets = new Map();
        this.stopped = false;
        this._listenConnections();
    }
    createDynamicStatic(path) {
        let staticFolder = express.static(path);
        this.dynamicStatic = function (req, res, next) {
            return staticFolder(req, res, next);
        };
        // Method to change static path at runtime
        this.dynamicStatic.setPath = (newPath) => {
            staticFolder = express.static(newPath);
        };
        return this.dynamicStatic;
    }
    /**
    Get the base url for endpoints
    @returns {string}
    */
    getBaseUrl(path, mode, options) {
        path = path || '/api';
        mode = mode || this.app.mode;
        const appConf = this.app.config.get(mode, config_1.ConfigType.APP, options);
        if (mode == app_1.AppMode.PRODUCTION && appConf.live && appConf.live.url) {
            let base = appConf.live.url;
            if (base.substr(base.length - 1, 1) == '/') {
                base = base.substr(0, base.length - 1);
            }
            return base + path;
        }
        const conf = this.app.config.get(mode, config_1.ConfigType.SERVER, options);
        if (!conf) {
            return '';
        }
        let url = `${conf.ssl ? 'https' : 'http'}://${conf.host}`;
        if (conf.port != 80) {
            url += ':' + conf.port;
        }
        url += path;
        return url;
    }
    /**
    Return true if the server is started
    @returns {boolean}
    */
    isStarted() { return this.started; }
    /**
    Return true if the server has a static page
    @returns {boolean}
    */
    hasStatic() {
        // DEPRECATED or should call this.app.client.hasIndexFile() as it's not the concern of the server implementation to know about the client
        const clientConfig = this.app.config.get(this.app.mode, config_1.ConfigType.CLIENT);
        let p;
        if (clientConfig && clientConfig.www) {
            p = clientConfig.www;
        }
        else {
            p = 'client';
        }
        return fs_extra_1.existsSync(path_1.join(this.app.path, p, 'index.html'));
    }
    /**
    Starts the server and listen on its endpoints.
    @returns {Promise<number>}
    */
    start(opts) {
        const clientConfig = this.app.config.get(this.app.mode, config_1.ConfigType.CLIENT);
        return new Promise((resolve, reject) => {
            this.stop().then(() => {
                if (!opts || !opts.fallback) {
                    let webDir;
                    // console.log(clientConfig);
                    if (clientConfig && clientConfig.www) {
                        webDir = clientConfig.www;
                    }
                    else {
                        webDir = 'client';
                    }
                    // Initialize dynamic Express static Object.
                    this.createDynamicStatic(path_1.join(this.app.path, webDir));
                    this.expressApp.use(this.dynamicStatic);
                    this.app.api.registerEndpoints();
                    this.expressApp.all('/api/*', (req, res) => {
                        res.status(404).send({
                            error: true,
                            message: 'API endpoint not found'
                        });
                    });
                    this.expressApp.all('/*', (req, res) => {
                        if (clientConfig && fs_extra_1.existsSync(path_1.join(this.app.path, clientConfig.www, '404.html'))) {
                            res.sendFile(path_1.join(this.app.path, clientConfig.www, '404.html'));
                        }
                        else if (this.hasStatic()) {
                            res.sendFile(path_1.join(this.app.path, clientConfig.www, 'index.html'));
                        }
                        else {
                            res.status(404).send({
                                error: true,
                                message: 'API endpoint not found'
                            });
                        }
                    });
                    this.expressApp.use((err, req, res) => {
                        res.status(500).send({
                            error: true,
                            message: (err && err.message) || 'Unexpected error'
                        });
                        return this.expressApp;
                    });
                    if (this.disabled) {
                        this.app.logger.log(' └── Server: Disabled (Warning)');
                        return resolve(0);
                    }
                }
                this.config = this.app.config.get(this.app.mode, config_1.ConfigType.SERVER);
                let port = opts && opts.port || this.app.options && this.app.options.port || this.config && this.config.port || 8080;
                if (this.app.mode == app_1.AppMode.PRODUCTION && process.env.GCLOUD_PROJECT && process.env.PORT) {
                    port = +process.env.PORT;
                }
                if (!port) {
                    if (app_1.AppMode.DEVELOPMENT === this.app.mode) {
                        port = 8080;
                    }
                    else {
                        port = 80;
                    }
                }
                let error = 0;
                const errListener = (e) => {
                    if (e.code == 'EADDRINUSE') {
                        this.app.logger.error(new Error(`Impossible to start the server - The port ${port} is already used by another server.`));
                        if (this.app.mode == app_1.AppMode.DEVELOPMENT) {
                            if (!opts) {
                                opts = {};
                            }
                            if (!opts.port) {
                                opts.port = port + 1;
                            }
                            error = port;
                            return this.start(opts).then(resolve).catch(reject);
                        }
                    }
                    else {
                        this.app.logger.error(new Error('Impossible to start the server - ' + e.message));
                    }
                    return reject(e);
                };
                const args = [port, this.config && this.config.host || 'localhost', () => {
                        if (port == error) {
                            return;
                        }
                        this.started = true;
                        this.app.logger.log(` └─┬ Server: ${chalk_1.default.green.bold('Started')}`);
                        if (this.config && this.config.host == '0.0.0.0' || process.env.NO_HOST) {
                            this.app.logger.log('   └─ Listening on ' + chalk_1.default.blue.bold.underline(`http://localhost:${port}`) + '\n');
                        }
                        else {
                            this.app.logger.log('   └─ Listening on ' + chalk_1.default.blue.bold.underline('http://' + (this.config && this.config.host || 'localhost') + ':' + port) + '\n');
                        }
                        this.server.removeListener('error', errListener);
                        return resolve(port);
                    }];
                // special IP - "no host"
                if (this.config && this.config.host == '0.0.0.0' || process.env.NO_HOST) {
                    // remove the host from args
                    args[1] = args.pop();
                }
                this.server.listen.apply(this.server, args).on('error', errListener);
            });
        });
    }
    /**
    Stops the server.
    */
    stop() {
        if (!this.server || !this.started) {
            return Promise.resolve();
        }
        return new Promise(accept => {
            this.websocket.close();
            this.server.close(() => {
                this.app.logger.log('\n' + chalk_1.default.bold('(Stop)') + ' Server closed\n');
                this.started = false;
                accept();
            });
            this.stopped = true;
            setImmediate(() => {
                this.sockets.forEach((reqs, socket) => {
                    socket.end();
                    socket.destroy();
                });
            });
        });
    }
    _onConnection(socket) {
        this.sockets.set(socket, 0);
        socket.once('close', () => this.sockets.delete(socket));
    }
    _onRequest(req, res) {
        this.sockets.set(req.socket, this.sockets.get(req.socket) + 1);
        res.once('finish', () => {
            const pending = this.sockets.get(req.socket) - 1;
            this.sockets.set(req.socket, pending);
            if (this.stopped && pending === 0) {
                req.socket.end();
                req.socket.destroy();
            }
        });
    }
    _listenConnections() {
        this.server.on('connection', socket => this._onConnection(socket));
        this.server.on('secureConnection', socket => this._onConnection(socket));
        this.server.on('request', (req, res) => this._onRequest(req, res));
    }
}
exports.Server = Server;
//# sourceMappingURL=server.js.map