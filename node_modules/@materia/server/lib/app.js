"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events = require("events");
const chalk_1 = require("chalk");
const path_1 = require("path");
const fse = require("fs-extra");
const logger_1 = require("./logger");
const config_1 = require("./config");
const server_1 = require("./server");
const entities_1 = require("./entities");
const database_1 = require("./database");
const synchronizer_1 = require("./synchronizer");
const self_migration_1 = require("./self-migration");
const history_1 = require("./history");
const client_1 = require("./client");
const addons_1 = require("./addons");
const api_1 = require("./api");
const error_1 = require("./error");
const api_2 = require("../api");
const watcher_1 = require("./watcher");
const actions_1 = require("./actions");
var AppMode;
(function (AppMode) {
    AppMode[AppMode["DEVELOPMENT"] = 'dev'] = "DEVELOPMENT";
    AppMode[AppMode["PRODUCTION"] = 'prod'] = "PRODUCTION";
})(AppMode = exports.AppMode || (exports.AppMode = {}));
/**
 * @class App
 * @classdesc
 * The main objects are available from this class.
 * @property {Server} server - Access to the server's options
 * @property {Api} api - Access to the server's endpoints
 * @property {History} history - Access to the history and past actions
 * @property {Database} database - Access to the database methods
 * @property {Addons} addons - Access to the addons methods
 * @property {Entities} entities - Access to the app's entities
 */
class App extends events.EventEmitter {
    constructor(path, options) {
        super();
        this.path = path;
        this.options = options;
        // private packageJsonCache?: string
        this.materia_path = __dirname;
        this.mode = AppMode.DEVELOPMENT;
        this.loaded = false;
        this.live = false;
        process.env.TZ = 'UTC';
        if (!this.options) {
            this.options = {};
        }
        if (this.options.prod) {
            this.options.mode = 'prod';
        }
        if (!this.options.mode) {
            this.mode = AppMode.DEVELOPMENT;
        }
        else if (['development', 'dev', 'debug'].indexOf(this.options.mode) != -1) {
            this.mode = AppMode.DEVELOPMENT;
        }
        else if (this.options.mode == 'production' || this.options.mode == 'prod') {
            this.mode = AppMode.PRODUCTION;
            if (!this.options.runtimes) {
                this.options.runtimes = 'core';
            }
        }
        else {
            throw new error_1.MateriaError('Unknown mode', {
                // tslint:disable-next-line:max-line-length
                debug: 'Option --mode can be development (development/dev/debug) or production (production/prod). e.g. materia start --mode=prod or materia start --mode=dev'
            });
        }
        this.logger = new logger_1.Logger(this);
        this.history = new history_1.History(this);
        this.addons = new addons_1.Addons(this);
        this.entities = new entities_1.Entities(this);
        this.database = new database_1.Database(this);
        this.api = new api_1.Api(this);
        this.server = new server_1.Server(this);
        this.client = new client_1.Client(this);
        this.synchronizer = new synchronizer_1.Synchronizer(this);
        this.config = new config_1.Config(this);
        this.materiaApi = new api_2.MateriaApi(this);
        this.watcher = new watcher_1.Watcher(this);
        this.actions = new actions_1.Actions(this);
        this.status = false;
        this.selfMigration = new self_migration_1.SelfMigration(this);
    }
    loadMateria() {
        return this.doSelfMigrations()
            .then(() => {
            this.config.reloadConfig();
            const appConfig = this.config.get(this.mode, config_1.ConfigType.APP);
            if (appConfig) {
                this.package = appConfig.package;
                this.name = appConfig.name;
                this.version = appConfig.version;
                this.icon = appConfig.icon;
                this.rootPassword = appConfig.rootPassword;
            }
        });
    }
    startFallback() {
        this.server.load();
        this.materiaApi.initialize();
        return this.server.start({
            fallback: true
        }).then(port => port);
    }
    load() {
        let elapsedTimeQueries, elapsedTimeEntities, elapsedTimeAPI;
        const elapsedTimeGlobal = new Date().getTime();
        this.api.removeAll({ save: false });
        return this.loadMateria()
            .then(() => {
            this.logger.log(`${chalk_1.default.bold('(Load)')} Application: ${chalk_1.default.yellow.bold(this.name || this.package)}`);
            this.logger.log(` └── Path: ${chalk_1.default.bold(this.path)}`);
            this.logger.log(` └── Mode: ${chalk_1.default.bold(this.mode == AppMode.DEVELOPMENT ? 'Development' : 'Production')}`);
            this.database.load();
            return this.client.load();
        })
            .then(() => this.server.load())
            .then(() => this.database.start())
            .then(() => this.entities.clear())
            .then(() => this.server.session.initialize())
            .then(() => this.materiaApi.initialize())
            .then(() => this.logger.log(` └── Sessions: ${chalk_1.default.green.bold('OK')}`))
            .then(() => this.addons.loadAddons())
            .then(() => this.addons.loadFiles())
            .then(() => this.entities.loadFiles())
            .then(() => this.logger.log(' └─┬ Entities'))
            .then(() => elapsedTimeEntities = new Date().getTime())
            .then(() => this.addons.loadEntities())
            .then(() => this.entities.loadEntities())
            .then(() => this.entities.loadRelations())
            .then(() => 
        // tslint:disable-next-line:max-line-length
        this.logger.log(` │ └── ${chalk_1.default.green.bold('OK') + ' - Completed in ' + chalk_1.default.bold(((new Date().getTime()) - elapsedTimeEntities).toString() + 'ms')}`))
            .then(() => this.entities.resetModels())
            .then(() => this.logger.log(' └─┬ Queries'))
            .then(() => elapsedTimeQueries = new Date().getTime())
            .then(() => this.addons.loadQueries())
            .then(() => this.entities.loadQueries())
            .then(() => this.logger.log(' └─┬ Actions'))
            .then(() => elapsedTimeQueries = new Date().getTime())
            .then(() => this.addons.loadActions())
            .then(() => this.actions.load())
            .then(() => 
        // tslint:disable-next-line:max-line-length
        this.logger.log(` │ └── ${chalk_1.default.green.bold('OK') + ' - Completed in ' + chalk_1.default.bold(((new Date().getTime()) - elapsedTimeQueries).toString() + 'ms')}`))
            .then(() => this.api.resetControllers())
            .then(() => this.logger.log(` └─┬ API`))
            .then(() => elapsedTimeAPI = new Date().getTime())
            .then(() => this.addons.loadAPI())
            .then(() => this.api.load())
            .then(() => 
        // tslint:disable-next-line:max-line-length
        this.logger.log(` │ └── ${chalk_1.default.green.bold('OK') + ' - Completed in ' + chalk_1.default.bold(((new Date().getTime()) - elapsedTimeAPI).toString() + 'ms')}`))
            .then(() => this.watcher.load())
            .then(() => this.history.load())
            .then(() => this.logger.log(` └── ${chalk_1.default.green.bold('Successfully loaded in ' + ((new Date().getTime()) - elapsedTimeGlobal).toString() + 'ms')}\n`))
            .then(() => null);
    }
    createDockerfile(options) {
        const dockerfile = path_1.join(this.path, 'Dockerfile');
        const dbProd = this.config.get(AppMode.PRODUCTION, config_1.ConfigType.DATABASE);
        const webProd = this.config.get(AppMode.PRODUCTION, config_1.ConfigType.SERVER);
        let setupScript = 'npm install';
        if (this.server.hasStatic() && this.client.config.packageJsonPath != '') {
            setupScript += ` && cd ${this.client.config.packageJsonPath} && npm install`;
            if (this.client.hasBuildScript(client_1.ScriptMode.BUILD)) {
                setupScript += ` && npm run ${this.client.config.build}`;
            }
        }
        else if (this.client.hasBuildScript(client_1.ScriptMode.BUILD)) {
            setupScript += ` && npm run ${this.client.config.build}`;
        }
        fse.writeFileSync(dockerfile, `FROM node:10-alpine

RUN mkdir -p /app

# invalidate cache
RUN uptime

COPY . /app

WORKDIR /app

RUN ${setupScript}

ENV MATERIA_MODE production

EXPOSE ${webProd.port}
CMD ["npm", "start"]`);
        let dbstr = '';
        if (database_1.Database.isSQL(dbProd) && dbProd.type == 'postgres') {
            // dbport = 5432
            dbstr = `
    image: postgres:9.6.3-alpine
    environment:
      POSTGRES_USER: "${dbProd.username}"
      POSTGRES_PASSWORD: "${dbProd.password}"
      POSTGRES_DB: "${dbProd.database}"`;
        }
        else if (database_1.Database.isSQL(dbProd) && dbProd.type == 'mysql') {
            // dbport = 3306
            dbstr = `
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: "${dbProd.password}"
      MYSQL_DATABASE: "${dbProd.database}"`;
            if (dbProd.username != 'root') {
                dbstr += `
      MYSQL_USER: "${dbProd.username}"
      MYSQL_PASSWORD: "${dbProd.password}"`;
            }
        }
        fse.writeFileSync(path_1.join(this.path, 'docker-compose.yaml'), `version: "3"
services:
  db: ${dbstr}
  web:
    build: .
    ports:
      - "${webProd.port}:${webProd.port}"
    links:
      - db
    depends_on:
      - db
    environment:
      MATERIA_MODE: "production"
      NO_HOST: "true"`);
    }
    createAppYaml(options) {
        const appyaml = path_1.join(this.path, 'app.yaml');
        fse.writeFileSync(appyaml, `runtime: nodejs
env: flex

skip_files:
 - ^node_modules$
 - ^.materia/live$
 - ^.git$

env_variables:
  MATERIA_MODE: 'production'
  NO_HOST: true

beta_settings:
 cloud_sql_instances: ${options.project}:${options.region}:${options.instance}

manual_scaling:
  instances: ${options.scale}`);
    }
    saveGCloudSettings(settings) {
        fse.writeFileSync(path_1.join(this.path, '.materia', 'gcloud.json'), JSON.stringify(settings, null, 2));
    }
    setPackageScript(name, script) {
        let pkg;
        try {
            const content = fse.readFileSync(path_1.join(this.path, 'package.json')).toString();
            pkg = JSON.parse(content);
            pkg.scripts[name] = script;
            fse.writeFileSync(path_1.join(this.path, 'package.json'), JSON.stringify(pkg, null, 2));
        }
        catch (e) {
            if (e.code != 'ENOENT') {
                throw e;
            }
        }
    }
    saveMateria() {
        let pkg;
        try {
            const content = fse.readFileSync(path_1.join(this.path, 'package.json')).toString();
            pkg = JSON.parse(content);
        }
        catch (e) {
            if (e.code != 'ENOENT') {
                throw e;
            }
        }
        pkg.name = this.package;
        fse.writeFileSync(path_1.join(this.path, 'package.json'), JSON.stringify(pkg, null, 2));
    }
    /**
    Starts the materia app
    @returns {Promise<number>}
    */
    start() {
        const errors = {};
        this.logger.log(`${chalk_1.default.bold('(Start)')} Application ${chalk_1.default.yellow.bold(this.name)}`);
        const p = this.database.started ? Promise.resolve() : this.database.start();
        return p.catch((e) => {
            errors.db = e;
        }).then((e) => {
            if (this.database.disabled) {
                this.logger.log(` └── Database: ${chalk_1.default.red.bold('Disabled')}`);
            }
            else {
                this.logger.log(` └── Database: ${chalk_1.default.green.bold('OK')}`);
            }
            if (Object.keys(errors).length == 0) {
                return this.entities.start().catch((err) => {
                    errors.entities = err;
                });
            }
            else {
                return Promise.resolve();
            }
        }).then(() => {
            if (!this.database.disabled) {
                this.logger.log(` └── Entities: ${chalk_1.default.green.bold('OK')}`);
            }
            if (Object.keys(errors).length == 0) {
                return this.addons.start().catch((e) => {
                    errors.addons = e;
                });
            }
            else {
                return Promise.resolve();
            }
        }).then(() => {
            this.logger.log(` └── Addons: ${chalk_1.default.bold.green('OK')}`);
            if (Object.keys(errors).length == 0 && this.mode == AppMode.PRODUCTION && !this.live && !this.database.disabled) {
                return this.synchronizer.diff().then((diffs) => {
                    if (diffs && diffs.length == 0) {
                        this.logger.log(` └── Synchronize: ${chalk_1.default.bold('DB already up to date')}`);
                        return;
                    }
                    this.logger.log(` └─┬ Synchronize: ${chalk_1.default.yellow.bold('The database structure differs from entities.')}`);
                    return this.synchronizer.entitiesToDatabase(diffs, {}).then((actions) => {
                        // tslint:disable-next-line:max-line-length
                        this.logger.log(` │ └── Database: ${chalk_1.default.green.bold('Updated successfully')}. (Applied ${chalk_1.default.bold(actions.length.toString())} actions)`);
                    });
                }).catch((e) => {
                    this.logger.log(` │ └── Database: ${chalk_1.default.red.bold('Fail - An action could not be applied: ' + e)}`);
                    e.errorType = 'sync';
                    throw e;
                });
            }
        }).then(() => this.server.start({
            fallback: Object.keys(errors).length > 0
        }));
    }
    startWithoutFailure() {
        return this.server.start();
    }
    /**
    Stops the materia app
    @returns {Promise}
    */
    stop() {
        return this.server.stop()
            .then(() => this.database.stop())
            .then(() => this.watcher.dispose())
            .then(() => { this.status = false; });
    }
    getAllFiles(name, p) {
        name = name || this.name;
        p = p || this.path;
        // let results = []
        return new Promise((accept, reject) => {
            fse.readdir(p, (err, files) => {
                const promises = [];
                if (err) {
                    return reject(err);
                }
                files.forEach((file) => {
                    if (file != '.DS_Store' &&
                        file != '.git' &&
                        file != 'history.json' &&
                        file != 'history' &&
                        file != 'node_modules' &&
                        file != 'bower_components' &&
                        file != '_site') {
                        promises.push(this._getFile(file, p));
                    }
                });
                Promise.all(promises).then((results) => {
                    accept({
                        filename: name,
                        path: p,
                        fullpath: p,
                        children: results
                    });
                }, (reason) => {
                    reject(reason);
                });
            });
        });
    }
    getFile(filepath) {
        if (!filepath) {
            throw new Error('You must provide a file path to retieve');
        }
        if (!fse.existsSync(filepath)) {
            throw new Error('File with provided path not found');
        }
        const filename = path_1.basename(filepath);
        const basePath = path_1.dirname(filepath);
        const relativePath = path_1.normalize(path_1.relative(this.path, filepath));
        return {
            filename: filename,
            fullpath: filepath,
            path: basePath,
            relativepath: relativePath,
            isDir: false,
            extension: path_1.extname(filepath).replace('.', '')
        };
    }
    getFiles(depth, name, p) {
        const splittedName = this.path.split(path_1.sep);
        const length = splittedName.length;
        const appFolder = splittedName[length - 1];
        name = name || appFolder;
        p = p || this.path;
        const files = [];
        const folders = [];
        if (depth) {
            const children = fse.readdirSync(p);
            children.forEach((file) => {
                if (file != '.DS_Store' && file != '.git') {
                    const stats = fse.lstatSync(path_1.join(p, file));
                    if (stats.isDirectory()) {
                        folders.push(this.getFiles(depth - 1, file, path_1.join(p, file)));
                    }
                    else {
                        const fullpath = path_1.join(p, file);
                        const fileRelativepath = path_1.normalize(path_1.relative(this.path, fullpath));
                        files.push({
                            filename: file,
                            path: p,
                            isDir: false,
                            fullpath: fullpath,
                            relativepath: fileRelativepath,
                            extension: path_1.extname(file).replace('.', '')
                        });
                    }
                }
            });
        }
        const folderRelativepath = path_1.normalize(path_1.relative(this.path, p));
        return {
            filename: name,
            path: path_1.dirname(p),
            isDir: true,
            fullpath: p,
            relativepath: folderRelativepath,
            incomplete: !depth,
            children: [...folders, ...files]
        };
    }
    initializeStaticDirectory() {
        let p = Promise.resolve();
        if (!fse.existsSync(path_1.join(this.path, 'client'))) {
            fse.mkdirSync(path_1.join(this.path, 'client'));
            if (!fse.existsSync(path_1.join(this.path, 'client', 'index.html'))) {
                fse.writeFileSync(path_1.join(this.path, 'client', 'index.html'), `<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>Document</title>
	</head>
	<body>
		<h1>Hello world!</h1>
	</body>
	</html>`);
            }
            this.server.dynamicStatic.setPath(path_1.join(this.path, 'client'));
        }
        else {
            p = Promise.reject(new Error('Client folder already exists'));
        }
        return p;
    }
    getWatchableFiles() {
        const files = this.getFiles(5);
        return this._getWatchableFiles(files.children);
    }
    readFile(fullpath) {
        return fse.readFileSync(fullpath, 'utf-8');
    }
    saveFile(fullpath, content, opts) {
        let p = Promise.resolve();
        if (opts && opts.mkdir) {
            try {
                fse.mkdirpSync(path_1.dirname(fullpath));
            }
            catch (e) {
                p = Promise.reject(e);
            }
        }
        return p.then(() => {
            fse.writeFileSync(fullpath, content);
        }).catch((e) => {
            throw e;
        });
    }
    getMateriaVersion() {
        const pkg = require('../package.json');
        return pkg.version;
    }
    doSelfMigrations() {
        if (this.selfMigration) {
            return this.selfMigration.check().then(() => {
                delete this.selfMigration;
            });
        }
        return Promise.resolve();
    }
    _getFile(file, p) {
        return new Promise((accept, reject) => {
            fse.lstat(path_1.join(p, file), (err, stats) => {
                if (err) {
                    return reject(err);
                }
                if (stats.isDirectory()) {
                    this.getAllFiles(file, path_1.join(p, file)).then((res) => {
                        accept(res);
                    }).catch((e) => {
                        reject(e);
                    });
                }
                else {
                    accept({
                        filename: file,
                        path: p,
                        fullpath: path_1.join(p, file)
                    });
                }
            });
        });
    }
    _getWatchableFiles(files) {
        const res = [];
        for (const file of files) {
            if (!Array.isArray(file.children)) {
                const filenameSplit = file.filename.split('.');
                if (['json', 'js', 'coffee', 'sql'].indexOf(filenameSplit[filenameSplit.length - 1]) != -1) {
                    res.push(file);
                }
            }
            else {
                const t = this._getWatchableFiles(file.children);
                t.forEach((a) => { res.push(a); });
            }
        }
        return res;
    }
}
exports.App = App;
//# sourceMappingURL=app.js.map