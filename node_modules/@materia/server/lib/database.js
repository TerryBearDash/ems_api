"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const chalk_1 = require("chalk");
const sequelize_1 = require("sequelize");
const domain = require("domain");
const app_1 = require("./app");
const config_1 = require("./config");
const interface_1 = require("./database/interface");
const error_1 = require("./error");
const dialect = {
    postgres: 'PostgreSQL',
    mysql: 'MySQL',
    sqlite: 'SQLite'
};
/**
 * @class Database
 * @classdesc
 * Represent the connection to database
 */
class Database {
    constructor(app) {
        this.app = app;
        this.locked = false;
        this.interface = new interface_1.DatabaseInterface(this);
    }
    static isSQL(settings) {
        return settings.type != 'sqlite';
    }
    static isSQLite(settings) {
        return settings.type == 'sqlite';
    }
    /**
    Load the database configuration
    @param {object} - *optional* The settings of the database
    @returns {object}
    */
    load(settings) {
        this.disabled = false;
        if (!settings && this.app.path) {
            this.app.config.reloadConfig();
            if (this.app.live) {
                settings = this.app.config.get(this.app.mode, config_1.ConfigType.DATABASE, { live: true });
            }
            settings = settings || this.app.config.get(this.app.mode, config_1.ConfigType.DATABASE);
        }
        if (!settings || !settings.type) {
            this.disabled = true;
            this.app.logger.log(` └── Database: ${chalk_1.default.yellow.bold('No database configured!')}`);
            return false;
        }
        if (Database.isSQL(settings)) {
            this.host = this.app.options['database-host'] || settings.host || 'localhost';
            this.port = Number(this.app.options['database-port'] || settings.port);
            this.username = this.app.options['database-username'] || settings.username;
            this.password = this.app.options['database-password'] || settings.password;
            this.database = this.app.options['database-db'] || settings.database;
        }
        else if (Database.isSQLite(settings)) {
            this.storage = this.app.options['storage'] || settings.storage;
        }
        this.type = settings.type;
        this.started = false;
        let logging;
        if (this.app.options.logSql == true) {
            logging = (...args) => { this.app.logger.log.apply(this.app.logger, args); };
        }
        else if (this.app.options.logSql !== undefined) {
            logging = this.app.options.logSql;
        }
        else {
            logging = false;
        }
        this.opts = {
            dialect: this.type,
            host: this.host,
            port: this.port,
            logging: logging
        };
        if (this.type !== 'sqlite' && settings.ssl) {
            this.opts.dialectOptions = {
                ssl: true
            };
        }
        if (Database.isSQLite(settings)) {
            this.opts.storage = path_1.resolve(this.app.path, this.storage || 'database.sqlite');
        }
        if (this.app.mode == app_1.AppMode.PRODUCTION && process.env.GCLOUD_PROJECT && this.type == 'mysql') {
            try {
                const gcloudJsonPath = path_1.join(this.app.path, '.materia', 'gcloud.json');
                if (fs_extra_1.existsSync(gcloudJsonPath)) {
                    const gcloudSettings = JSON.parse(fs_extra_1.readFileSync(gcloudJsonPath, 'utf-8'));
                    this.opts.dialectOptions = { socketPath: `/cloudsql/${gcloudSettings.project}:${gcloudSettings.region}:${gcloudSettings.instance}` };
                    delete this.opts.host;
                    delete this.opts.port;
                }
                else {
                    throw new error_1.MateriaError('gcloud.json not found');
                }
            }
            catch (e) {
                this.app.logger.log(chalk_1.default.yellow(` └── Warning: Impossible to load GCloud database settings - ${chalk_1.default.bold(e)}`));
            }
        }
        this.app.logger.log(` └─┬ Database: ${chalk_1.default.green.bold('OK')}`);
        this.app.logger.log(` │ └── Dialect: ${chalk_1.default.bold(dialect[this.type])}`);
        if (this.type == 'sqlite') {
            this.app.logger.log(` │ └── File: ${chalk_1.default.bold(this.storage || 'database.sqlite')}`);
        }
        else {
            this.app.logger.log(` │ └── Host: ${chalk_1.default.bold(this.host)}`);
            this.app.logger.log(` │ └── Port: ${chalk_1.default.bold(this.port.toString())}`);
        }
        return true;
    }
    /**
    Try to connect with a custom configuration
    @param {object} - The configuration object
    @returns {Promise}
    */
    static tryDatabase(settings, app) {
        // TODO: check settings.storage to be a real path
        if (this.isSQLite(settings) && settings.storage) {
            return Promise.resolve();
        }
        const optsDialect = {
            dialect: settings.type,
            logging: false
        };
        let opts;
        if (Database.isSQL(settings)) {
            opts = Object.assign({}, optsDialect, {
                host: settings.host,
                port: settings.port
            });
        }
        else if (Database.isSQLite(settings) && app) {
            opts.storage = path_1.resolve(app.path, settings.storage || 'database.sqlite');
        }
        let tmp;
        return new Promise((accept, reject) => {
            const d = domain.create();
            try {
                if (Database.isSQL(settings)) {
                    tmp = new sequelize_1.Sequelize(settings.database, settings.username, settings.password, opts);
                }
                else if (Database.isSQLite(settings)) {
                    tmp = new sequelize_1.Sequelize(null, null, null, opts);
                }
            }
            catch (e) {
                return reject(e);
            }
            d.add(tmp.query);
            d.on('error', (e) => {
                d.remove(tmp.query);
                reject(e);
            });
            d.run(() => {
                tmp.authenticate().then(() => {
                    tmp.close();
                    accept();
                }).catch((e) => { reject(e); });
            });
        });
    }
    /**
    Try to connect database server default database with username password
    MySQL or PostgreSQL only
    @param {object} - The configuration object
    @returns {Promise}
     */
    static tryServer(settings, app) {
        if (Database.isSQL(settings)) {
            const opts = {
                dialect: settings.type,
                host: settings.host,
                port: settings.port,
                logging: false
            };
            let tmp;
            let defaultDatabase;
            if (settings.type == 'mysql') {
                defaultDatabase = 'sys';
            }
            else if (settings.type == 'postgres') {
                defaultDatabase = 'postgres';
            }
            return new Promise((accept, reject) => {
                const d = domain.create();
                try {
                    tmp = new sequelize_1.Sequelize(defaultDatabase, settings.username, settings.password, opts);
                }
                catch (e) {
                    return reject(e);
                }
                d.add(tmp.query);
                d.on('error', (e) => {
                    d.remove(tmp.query);
                    return reject(e);
                });
                d.run(() => {
                    return tmp.authenticate().then(() => {
                        tmp.close();
                        accept();
                    }).catch((e) => { reject(e); });
                });
            });
        }
        else {
            return Promise.reject(new Error("You can't try to connect to SQLite with username/password"));
        }
    }
    /**
    List databases in mysql or postgres instances
    MySQL and PostgreSQL only
    @param settings - The configuration object
    @returns {Promise}
     */
    static listDatabases(settings) {
        if (Database.isSQL(settings)) {
            const opts = {
                dialect: settings.type,
                host: settings.host,
                port: settings.port,
                logging: false
            };
            let tmp;
            let defaultDatabase;
            if (settings.type == 'mysql') {
                defaultDatabase = 'sys';
            }
            else if (settings.type == 'postgres') {
                defaultDatabase = 'postgres';
            }
            return new Promise((accept, reject) => {
                try {
                    tmp = new sequelize_1.Sequelize(defaultDatabase, settings.username, settings.password, opts);
                    if (settings.type == 'mysql') {
                        tmp.query(`SHOW DATABASES`).spread((results, metadata) => {
                            const formatedResult = [];
                            for (const i in results) {
                                if (results[i]) {
                                    const result = results[i];
                                    formatedResult.push(result.Database);
                                }
                            }
                            return accept(formatedResult);
                        });
                    }
                    else if (settings.type == 'postgres') {
                        tmp.query(`SELECT datname FROM pg_database`).spread((results, metadata) => {
                            const formatedResult = [];
                            for (const i in results) {
                                if (results[i]) {
                                    const result = results[i];
                                    formatedResult.push(result.datname);
                                }
                            }
                            return accept(formatedResult);
                        });
                    }
                }
                catch (e) {
                    return reject(e);
                }
            });
        }
        else {
            return Promise.reject(new Error(`You can't list database on a SQLite database`));
        }
    }
    /**
     Create new database in mysql or postgresql instances
     @param settings - The configuration object
     @param name - Name for the new database
     */
    static createDatabase(settings, name) {
        const opts = {
            dialect: settings.type,
            host: settings.host,
            port: settings.port,
            logging: false
        };
        let tmp;
        let defaultDatabase;
        if (settings.type == 'mysql') {
            defaultDatabase = 'sys';
        }
        else if (settings.type == 'postgres') {
            defaultDatabase = 'postgres';
        }
        return new Promise((accept, reject) => {
            const dbName = defaultDatabase === 'sys' ? '`' + `${name}` + '`' : `"${name}"`;
            try {
                tmp = new sequelize_1.Sequelize(defaultDatabase, settings.username, settings.password, opts);
            }
            catch (e) {
                return reject(e);
            }
            return tmp.query(`CREATE DATABASE ${dbName}`).spread((results, metadata) => {
                return accept();
            }).catch(err => reject(err.message));
        });
    }
    tryDatabase(settings) {
        return Database.tryDatabase(settings, this.app);
    }
    tryServer(settings) {
        return Database.tryServer(settings, this.app);
    }
    listDatabases(settings) {
        return Database.listDatabases(settings);
    }
    createDatabase(settings, name) {
        return Database.createDatabase(settings, name);
    }
    /**
    Connect to the database
    @returns {Promise}
    */
    start() {
        if (this.sequelize) {
            this.stop();
        }
        if (this.disabled) {
            return Promise.resolve();
        }
        if (!this.interface.hasDialect(this.type)) {
            return Promise.reject(new error_1.MateriaError('The database\'s dialect is not supported'));
        }
        this.app.emit('db:start');
        try {
            this.sequelize = new sequelize_1.Sequelize(this.database, this.username, this.password, this.opts);
        }
        catch (e) {
            this.disabled = true;
            return Promise.reject(e);
        }
        this.interface.setDialect(this.type);
        return this.interface.authenticate().then(() => {
            this.app.logger.log(` └── Database: ${chalk_1.default.green.bold('Authenticated')}`);
            this.started = true;
        }).catch((e) => {
            this.app.logger.error(` └── Database: ${chalk_1.default.red.bold('Connection failed')}`);
            this.app.logger.error(chalk_1.default.red('    (Warning) Impossible to connect the database: ') + chalk_1.default.red.bold(e && e.message));
            this.app.logger.error(chalk_1.default.red('    The database has been disabled'));
            this.disabled = true;
            return Promise.resolve(e);
        });
    }
    /**
    Stop the database connection
    */
    stop() {
        this.started = false;
        if (this.sequelize) {
            this.sequelize.close();
            this.sequelize = null;
        }
        return Promise.resolve();
    }
    /**
    Synchronize the database with the state of the application
    @returns {Promise}
    */
    sync() {
        return this.app.entities.sync().then(() => {
            return this.sequelize.sync();
        });
    }
    // Deprecated: use sync() instead as sequelize({force: true}) will remove all data
    forceSync() {
        return this.app.entities.sync().then(() => {
            return this.sequelize.sync({ force: true });
        });
    }
}
exports.Database = Database;
//# sourceMappingURL=database.js.map